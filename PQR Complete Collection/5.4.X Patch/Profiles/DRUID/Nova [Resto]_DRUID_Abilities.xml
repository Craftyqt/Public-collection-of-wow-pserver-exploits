<?xml version="1.0" encoding="utf-8" ?><DRUID><Ability><Name>-- Init --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if PQR_RotationStarted == true then
	-- Should be reloaded every time you reload Profile (No more needing to /rl)
	PQR_RotationStarted = false


PQR_Event(&amp;quot;PQR_Text&amp;quot;, &amp;quot;Druid Profile Verions - 0.3&amp;quot;, nil, &amp;quot;00FF00&amp;quot;)
PQR_SwapCheckTimer = 0
PQR_SwapCheck = false

if PQR_LoadLua ~= nil then
	-- Load Data File
	if PQR_LoadLua(&amp;quot;PQR_Nova_Data.lua&amp;quot;) == false then
		PQR_WriteToChat(&amp;quot;You are missing PQR_Nova_Data.lua. Rotation has been stopped.&amp;quot;, &amp;quot;Error&amp;quot;)
		PQR_StopRotation()
		return true
	end

	if not PQR_LoadLua(&amp;quot;PQR_PQI.lua&amp;quot;) then
		print(&amp;quot;Missing the PQI Data File!!! Rotation has Stopping&amp;quot;, &amp;quot;Error&amp;quot;)
		PQR_StopRotation()
		return true
	end
end

PQR_Spec = GetSpecialization()
if PQR_Spec ~= 4 then
	PQR_WriteToChat(&amp;quot;You must be in Resto Spec. Please switch then try again.&amp;quot;, &amp;quot;Warning&amp;quot;)
	PQR_StopRotation()
	return true
end



  -- Checking if there&amp;apos;s a dangerous Debuff we shouldn&amp;apos;t Cleanse  
  function DontDispel(t)
      local buff  = { 30108, 34914 }
      local DontDispelCheck = false
      for i=1, #buff do
      	if UnitDebuffID(t, buff[i]) then
			if select(11, UnitDebuff(t, GetSpellInfo(buff[i]))) == 30108 then
		    	if UnitDebuffID(t, 31117) then
		    		if select(11, UnitDebuff(t, GetSpellInfo(31117))) == 31117 then
		    				DontDispelCheck = false
		    				break
		    		end
		    	else
		    	 		DontDispelCheck = true
		    	end
		     	DontDispelCheck = true
		    end
		end
	  end
	  return DontDispelCheck
  end

  -- Checking if there&amp;apos;s a Dangerous Debuff we need to cleanse Immediately
  function DangerousMagic(t)
    local buff = { 118 }
    for _,v in ipairs(buff) do if UnitDebuffID(t,v) then return true end end
  end
  
  -- Checks if our Cleanse will have a valid Debuff to Cleanse
  function ValidDispel(t)
  	local HasValidDispel = false
  	local i = 1
  	local debuff = UnitDebuff(t, i)
  	while debuff do
  		local debuffType = select(5, UnitDebuff(t, i))
  		if debuffType == &amp;quot;Magic&amp;quot; or debuffType == &amp;quot;Poison&amp;quot; or debuffType == &amp;quot;Curse&amp;quot; then
  			HasValidDispel = true
  		end
  		i = i + 1
  		debuff = UnitDebuff(t, i)
  	end
  	return HasValidDispel
  end


	-- Average Health of Players
	function AverageHealth(n) -- N = Size of the range of people we are checking
		local NumberOfPeople = n
		local Nova_Average = 0
		if #members &amp;lt; NumberOfPeople then
			for i=NumberOfPeople, 0, -1 do
				if #members &amp;gt;= i then
					NumberOfPeople = i
					break
				end
			end
		end
		
		for i=1, NumberOfPeople do
			Nova_Average = Nova_Average + members[i].HP 
		end
		
		Nova_Average = Nova_Average / NumberOfPeople
		
		return Nova_Average, NumberOfPeople
	end

if GetCVar(&amp;quot;PQ_WipeCustomTable&amp;quot;) == nil then RegisterCVar(&amp;quot;PQ_WipeCustomTable&amp;quot;, 0) end
if GetCVar(&amp;quot;Nova_OverRide&amp;quot;) == nil then RegisterCVar(&amp;quot;Nova_OverRide&amp;quot;, 0) end
if GetCVar(&amp;quot;PQ_UseCustomT&amp;quot;) == nil then RegisterCVar(&amp;quot;PQ_UseCustomT&amp;quot;, 0) end
if GetCVar(&amp;quot;Nova_Recording&amp;quot;) == nil then RegisterCVar(&amp;quot;Nova_Recording&amp;quot;, 0) end
if GetCVar(&amp;quot;Nova_DisableCD&amp;quot;) == nil then RegisterCVar(&amp;quot;Nova_DisableCD&amp;quot;, 1) end
if GetCVar(&amp;quot;Nova_Mouseover&amp;quot;) == nil then RegisterCVar(&amp;quot;Nova_Mouseover&amp;quot;, 0) end
if GetCVar(&amp;quot;Nova_LowHP&amp;quot;) == nil then RegisterCVar(&amp;quot;Nova_LowHP&amp;quot;, 80) end
if GetCVar(&amp;quot;Nova_ActualHP&amp;quot;) == nil then RegisterCVar(&amp;quot;Nova_ActualHP&amp;quot;, 0) end


-------------------
-- PQI Setup
-------------------

if not PQI_Setup_Healing then
	PQI_Healing_Druid = {
		name = &amp;apos;Resto Healing Spells&amp;apos;,
		author = &amp;apos;Nova&amp;apos;,
		abilities = {
			{name = &amp;apos;Rejuvenation&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 80,
				step = 1,
				},
			},			
			{name = &amp;apos;Wild Growth&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 88,
				step = 1,
				},
			},
			{name = &amp;apos;Nourish&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 60,
				step = 1,
				},
			},
			{name = &amp;apos;Healing Touch&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 50,
				step = 1,
				},
			},
			{name = &amp;apos;Swiftmend&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 75,
				step = 1,
				},
			},
			{name = &amp;apos;Regrowth&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 70,
				step = 1,
				},
			},
			{name = &amp;apos;Genesis&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 60,
				step = 1,
				},
			},
			
			{name = &amp;apos;Genesis ST&amp;apos;,
			enable = true,
			tooltip = &amp;apos;What health % should we heal a single wounded target with Genesis?&amp;quot;&amp;apos;,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 40,
				step = 1,
				},
			},
			{name = &amp;apos;NaturesCure&amp;apos;,
			enable = true,
			tooltip = &amp;apos;Will only cleanse when health is above this number.&amp;apos;,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 50,
				step = 1,
				},
			},
			{name = &amp;apos;Wild Mushroom&amp;apos;,
			enable = true,
			},
			{name = &amp;apos;Wild Mushroom Bloom&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 70,
				step = 1,
				},
			},
			{name = &amp;apos;Wild Mushroom Bloom Perc&amp;apos;,
			tooltip = &amp;apos;At what % of Player Max Health do we allow Bloom to cast?&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 30,
				step = 1,
				},
			},
			{name = &amp;apos;Rejuvenation SotF&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 80,
				step = 1,
				},
			},
			{name = &amp;apos;Wild Growth SotF&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 92,
				step = 1,
				},
			},
			{name = &amp;apos;Healing Touch CC&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 70,
				step = 1,
				},
			},
			{name = &amp;apos;Regrowth CC&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 80,
				step = 1,
				},
			}
		},
		hotkeys = {
			{name = &amp;apos;Pause&amp;apos;,
			enable = true,
			hotkeys = {&amp;apos;la&amp;apos;},
			},
			{name = &amp;apos;Lifebloom Selector&amp;apos;,
			enable = true,
			hotkeys = {&amp;apos;rs&amp;apos;},
			},
			{name = &amp;apos;Remove From Custom Table&amp;apos;,
			enable = true,
			hotkeys = {&amp;apos;rc&amp;apos;},
			},
			{name = &amp;apos;Add To Custom Table&amp;apos;,
			enable = true,
			hotkeys = {&amp;apos;ra&amp;apos;},
			},
			{name = &amp;apos;Add Or Remove Blacklist&amp;apos;,
			enable = false,
			hotkeys = { &amp;apos;ra&amp;apos;, &amp;apos;rc&amp;apos; },
			},
			{name = &amp;apos;Pause Toggle&amp;apos;,
			enable = true,
			hotkeys = { &amp;apos;ra&amp;apos;, &amp;apos;rs&amp;apos; },
			},
		}
	}
	
	PQI_Cooldown_Druid = {
		name = &amp;apos;Resto Healing Cooldowns&amp;apos;,
		author = &amp;apos;Nova&amp;apos;,
		abilities = {
			{name = &amp;apos;Innervate&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 80,
				step = 1,
				},
			},
			{name = &amp;apos;Ironbark&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 30,
				step = 1,
				},
			},
			{name = &amp;apos;Natures Vigil&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 70,
				step = 1,
				},
			},
			{name = &amp;apos;Natures Swiftness&amp;apos;,
			enable = true,
			widget = {
				type = &amp;apos;numbox&amp;apos;,
				value = 60,
				step = 1,
				},
			},
		},
		
		hotkeys = {
			{name = &amp;apos;Tranquility&amp;apos;,
			enable = true,
			hotkeys = {&amp;apos;ls&amp;apos;},
			},
			{name = &amp;apos;Incarnation&amp;apos;,
			enable = true,
			hotkeys = {&amp;apos;lc&amp;apos;},
			},			
			{name = &amp;apos;Heart of the Wild&amp;apos;,
			enable = false,
			tooltip = &amp;apos;Not yet implemented&amp;apos;,
			hotkeys = {&amp;apos;lc&amp;apos;,&amp;apos;la&amp;apos;},
			},
		},	
	}

	PQI_Setup_Healing = PQI:AddRotation(PQI_Cooldown_Druid)
	PQI_Setup_Healing = PQI:AddRotation(PQI_Healing_Druid)
	pqiTimer = GetTime()
end


function PQI_Setup_Variables(tableName, Prefix) -- Name of the PQI Table, [Prefix you want to affix to Variable (Nova is default if left blank)]
	local tableName = tableName
	local Prefix = Prefix or &amp;quot;Nova&amp;quot;
	if type(Prefix) ~= &amp;quot;string&amp;quot; then
		Prefix = &amp;quot;Nova&amp;quot;
	end
	local PQI_String = string.format(&amp;quot;%s_%s%s&amp;quot;, &amp;quot;PQI&amp;quot;, gsub(tableName.author, &amp;quot;%s&amp;quot;, &amp;quot;&amp;quot;), gsub(tableName.name, &amp;quot;%s&amp;quot;, &amp;quot;&amp;quot;))
	if type(tableName.abilities) == &amp;quot;table&amp;quot; then
		for i=1, #tableName.abilities do
			local AbilitiesName = gsub(tableName.abilities[i].name, &amp;apos;%s&amp;apos;, &amp;apos;&amp;apos;)
			local Variable = string.format(&amp;apos;%s_%s&amp;apos;, Prefix, AbilitiesName)
			local PQI_String_Enable = string.format(&amp;quot;%s_%s_%s&amp;quot;, PQI_String, AbilitiesName, &amp;quot;enable&amp;quot;)
			local PQI_String_Value = string.format(&amp;quot;%s_%s_%s&amp;quot;, PQI_String, AbilitiesName, &amp;quot;value&amp;quot;)
			
			if _G[PQI_String_Enable] ~= nil then -- This is to verify that PQI is fully loaded before trying to make the Variables
				_G[Variable..&amp;apos;_Check&amp;apos;] = _G[tostring(PQI_String_Enable)] -- Output = Prefix_AbilityName_Check
				_G[Variable] = _G[tostring(PQI_String_Value)] -- Output = Prefix_AbilityName
			else
				return false
			end
		end
	end
	if type(tableName.hotkeys) == &amp;quot;table&amp;quot; then
		for h=1, #tableName.hotkeys do
			local HotkeyName = gsub(tableName.hotkeys[h].name, &amp;apos;%s&amp;apos;, &amp;apos;&amp;apos;)
			local Variable = string.format(&amp;apos;%s_%s%s&amp;apos;, Prefix, &amp;quot;Mod&amp;quot;, HotkeyName)
			local PQI_String_Enable = string.format(&amp;quot;%s_%s_%s&amp;quot;, PQI_String, HotkeyName, &amp;quot;enable&amp;quot;)
			local PQI_String_Key = string.format(&amp;apos;%s_%s_%s&amp;apos;, PQI_String, HotkeyName, &amp;quot;key&amp;quot;)
			
			if _G[PQI_String_Key] ~= nil then
				_G[Variable..&amp;apos;_Check&amp;apos;] = _G[tostring(PQI_String_Enable)] -- Output = Prefix_ModAbilityName_Check
				_G[Variable] = PQI:IsHotkeys(_G[PQI_String_Key]) -- Output = Prefix_ModAbilityName_Key
			else
				return false
			end
		end
	end

	return true
end


--------------------
-- Slash Commands
--------------------
SLASH_WIPETABLE1 = &amp;quot;/wipetable&amp;quot;
SLASH_WIPETABLE2 = &amp;quot;/wipecustomtable&amp;quot;
SLASH_WIPETABLE3 = &amp;quot;/wt&amp;quot;
function SlashCmdList.WIPETABLE(msg, editbox)
	Nova_CustomT = { }
	if GetCVarBool(&amp;quot;PQ_UseCustomT&amp;quot;) then 
		SetCVar(&amp;quot;PQ_UseCustomT&amp;quot;, 0)
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Wiped Custom Table clean, and reverting to Normal Table.&amp;quot;)
		end
	else
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Wiped Custom Table clean.&amp;quot;)
		end
	end
end

SLASH_USECUSTOMT1 = &amp;quot;/usecustomt&amp;quot;
SLASH_USECUSTOMT2 = &amp;quot;/uct&amp;quot;
SLASH_USECUSTOMT3 = &amp;quot;/usecustomtable&amp;quot;
function SlashCmdList.USECUSTOMT(msg, editbox)
	if not GetCVarBool(&amp;quot;PQ_UseCustomT&amp;quot;) and #Nova_CustomT &amp;gt; 0 then
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Enabling Custom Table&amp;quot;)
		end
		SetCVar(&amp;quot;PQ_UseCustomT&amp;quot;, 1)
	else
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Enabling Normal Table&amp;quot;)
		end
		SetCVar(&amp;quot;PQ_UseCustomT&amp;quot;, 0)
	end
end

SLASH_RECORDING1 = &amp;quot;/recording&amp;quot;
SLASH_RECORDING2 = &amp;quot;/recraid&amp;quot;
SLASH_RECORDING3 = &amp;quot;/recordingraid&amp;quot;
function SlashCmdList.RECORDING(msg, editbox)
	if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
		SetCVar(&amp;quot;Nova_Recording&amp;quot;, 1)
		for i=1, 20 do ChatFrame1:AddMessage(&amp;quot; &amp;quot;) end
	else
		PQR_WriteToChat(&amp;quot;Silent Mode Disabled&amp;quot;)
		SetCVar(&amp;quot;Nova_Recording&amp;quot;, 0)
	end
end

SLASH_DISABLECD1 = &amp;quot;/disablecd&amp;quot;
function SlashCmdList.DISABLECD(msg, editbox)
	if not GetCVarBool(&amp;quot;Nova_DisableCD&amp;quot;) then
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Disabling your Automatic Cooldown Usage&amp;quot;)
		end
		SetCVar(&amp;quot;Nova_DisableCD&amp;quot;, 1)
	else
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Enabling your Automatic Cooldown Usage&amp;quot;)
		end
		SetCVar(&amp;quot;Nova_DisableCD&amp;quot;, 0)
	end
end

SLASH_CLEARCHAT1 = &amp;quot;/clearchat&amp;quot;
function SlashCmdList.CLEARCHAT(msg, editbox)
	for i=1, 20 do
		ChatFrame1:AddMessage(&amp;quot; &amp;quot;)
	end
end


SLASH_DISABLECLEANSE1 = &amp;quot;/disablecleanse&amp;quot;
function SlashCmdList.DISABLECLEANSE(msg, editbox)
	if not GetCVarBool(&amp;quot;Nova_DisableCleanse&amp;quot;) then
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Disabled Cleanse.&amp;quot;)
		end
		SetCVar(&amp;quot;Nova_DisableCleanse&amp;quot;, 1)
	else
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Enabled Cleanse.&amp;quot;)
		end
		SetCVar(&amp;quot;Nova_DisableCleanse&amp;quot;, 0)
	end		
end

SLASH_DISABLEMOUSEOVER1 = &amp;quot;/mouseoverheal&amp;quot;
SLASH_DISABLEMOUSEOVER2 = &amp;quot;/mh&amp;quot;
function SlashCmdList.DISABLEMOUSEOVER(msg, editbox)
	if not GetCVarBool(&amp;quot;Nova_Mouseover&amp;quot;) then
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Disabled Mouseover.&amp;quot;)
		end
		SetCVar(&amp;quot;Nova_Mouseover&amp;quot;, 1)
	else
		if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
			PQR_WriteToChat(&amp;quot;Enabled Mouseover.&amp;quot;)
		end
		SetCVar(&amp;quot;Nova_Mouseover&amp;quot;, 0)
	end		
end

-- Variables
PQR_ResetMovementTime = 0.3
PQR_SpellAvailableTime = ((select(3,GetNetStats()) + select(4,GetNetStats())) / 1000)
PQR_AddToSpellDelayList(18562, 0, 1) -- Swiftmend
end

SheuronEngine(Nova_Mouseover, Nova_LowHP, Nova_ActulHP)  -- Deactivate Mouseover  ||   At what % Health do we consider someone LowHP  ||  Sort by Actual Health = true

TableCompilation = { members, Nova_CustomT, Nova_Tanks } -- Visual Healing Table Currently disabled

if not _G.FrameSetup then
	VisualTableFrameSetup(TableCompilation)
	VHT_Timer = 0
-- Setup the Slash Commands for the Frame
	SLASH_VHTFRAME1 = &amp;quot;/visualhealing&amp;quot;
	SLASH_VHTFRAME2 = &amp;quot;/vht&amp;quot;
	function SlashCmdList.VHTFRAME(msg, editbox)
		local VHT = _G[&amp;apos;VisualHealingTableTitle&amp;apos;]
		if not VHT:IsShown() then
			VHT:Show()
		else
			VHT:Hide()
		end
	end
end

if GetTime() - _G[&amp;apos;VHT_Timer&amp;apos;] &amp;gt;= 0.5 and _G[&amp;apos;VisualHealingTableTitle&amp;apos;]:IsVisible() then
	UpdateFontStrings(TableCompilation)
end

if not PQI_Setup_Variables(PQI_Healing_Druid, &amp;quot;Nova&amp;quot;) 
 or not PQI_Setup_Variables(PQI_Cooldown_Druid, &amp;quot;Nova&amp;quot;) 
 or (Nova_ModPause
 and Nova_ModPause_Check)
 or UnitIsDeadOrGhost(&amp;quot;player&amp;quot;) 
 or IsMounted() then
 	return true
elseif GetShapeshiftForm() &amp;gt; 0 then
	if select(2, GetShapeshiftFormInfo(GetShapeshiftForm())) == GetSpellInfo(40120) then 
 		return true
 	end 
end

if GetTime() - PQR_SwapCheckTimer &amp;gt; 1 then
	if Nova_ModPauseToggle_Check then
		if Nova_ModPauseToggle then
			if PQR_SwapCheck then
				PQR_SwapCheck = false
			else
				PQR_SwapCheck = true
			end
		end
	end
end

if PQR_SwapCheck then
	return true
end

if UnitBuffID(&amp;quot;player&amp;quot;, 132158) then
	Nova_Moving = false
elseif PQR_IsMoving() then
	Nova_Moving = true
else
	Nova_Moving = false
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Custom Table --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>--------------------------------------
-- Adding Players to Custom Table
--------------------------------------
if Nova_ModAddToCustomTable
 and Nova_ModAddToCustomTable_Check
 and UnitExists(&amp;quot;mouseover&amp;quot;)
 and ( CanHeal(&amp;quot;mouseover&amp;quot;) 
  or UnitIsUnit(&amp;quot;player&amp;quot;, &amp;quot;mouseover&amp;quot;) ) then
	for i=1, #Nova_CustomT do
		if Nova_CustomT[i].GUID and Nova_CustomT[i].GUID == UnitGUID(&amp;quot;mouseover&amp;quot;) then
			return false
		end
	end
	
	table.insert(Nova_CustomT, { GUID = UnitGUID(&amp;quot;mouseover&amp;quot;) } )
	
	if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
		PQR_WriteToChat(&amp;quot;We just added &amp;quot;..UnitName(&amp;quot;mouseover&amp;quot;)..&amp;quot; to the Custom Healing Table.&amp;quot;, &amp;quot;Alert&amp;quot;)
	end
	return true

end


--------------------------------------
-- Removing Players from Custom Table
--------------------------------------

if Nova_ModRemoveFromCustomTable
 and Nova_ModRemoveFromCustomTable_Check
 and UnitExists(&amp;quot;mouseover&amp;quot;)
 and ( CanHeal(&amp;quot;mouseover&amp;quot;) 
  or UnitIsUnit(&amp;quot;player&amp;quot;, &amp;quot;mouseover&amp;quot;) )then
	for i=1, #Nova_CustomT do
		if Nova_CustomT[i].GUID and Nova_CustomT[i].GUID == UnitGUID(&amp;quot;mouseover&amp;quot;) then
			if not GetCVarBool(&amp;quot;Nova_Recording&amp;quot;) then
				PQR_WriteToChat(&amp;quot;We just removed &amp;quot;..UnitName(Nova_CustomT[i].Unit)..&amp;quot; from the Custom Healing Table.&amp;quot;, &amp;quot;Alert&amp;quot;)
			end
			table.remove(Nova_CustomT, i)
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Healing Engine --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if GetCVarBool(&amp;quot;PQ_UseCustomT&amp;quot;) then
	members = Nova_CustomT
	lowhpmembers = 0
	for i=1, #Nova_CustomT do
		if Nova_CustomT[i].HP &amp;lt; 80 then
			lowhpmembers = lowhpmembers + 1
		end
	end
	
	table.sort(members, function(x,y) return x.HP &amp;lt; y.HP end)
end

TableCompilation = { members, Nova_CustomT, Nova_Tanks }</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Rejuvenation</Name><Default>false</Default><SpellID>774</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(774)  
 and Nova_Rejuvenation_Check then
	if #Nova_Tanks &amp;gt; 0 then
		for y=1, #Nova_Tanks do
			if not UnitBuffID(Nova_Tanks[y].Unit, 774, &amp;quot;PLAYER&amp;quot;) then
			 	PQR_CustomTarget = Nova_Tanks[y].Unit
			 	return true
			end
		end
	end
	for i=1, #members do
		if not UnitBuffID(members[i].Unit, 774)
		 and members[i].HP &amp;lt; Nova_Rejuvenation then
		 	PQR_CustomTarget = members[i].Unit
		 	return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Lifebloom</Name><Default>false</Default><SpellID>33763</SpellID><Actions></Actions><Lua>local members = members

if UnitExists(&amp;quot;focus&amp;quot;)
 and CanHeal(&amp;quot;focus&amp;quot;) then
 	LifeBloom = UnitGUID(&amp;quot;focus&amp;quot;)
elseif Nova_ModLifebloomSelector then
	if CanHeal(&amp;quot;mouseover&amp;quot;) 
	 or UnitIsUnit(&amp;quot;player&amp;quot;, &amp;quot;mouseover&amp;quot;) then
		LifeBloom = UnitGUID(&amp;quot;mouseover&amp;quot;)
		PQR_CustomTarget = &amp;quot;mouseover&amp;quot;
		return true
	end
end

if LifeBloom and ( UnitAffectingCombat(&amp;quot;player&amp;quot;) or UnitAffectingCombat(members[1].Unit) ) then
	for i=1, #members do
		if LifeBloom == members[i].GUID then
			if UnitBuffID(members[i].Unit, 33763) then
				if select(7, UnitBuffID(members[i].Unit, 33763)) - GetTime() &amp;lt;= 3 
				 or select(4, UnitBuffID(members[i].Unit, 33763)) &amp;lt; 3 then
					PQR_CustomTarget = members[i].Unit
					return true
				end
			else
				PQR_CustomTarget = members[i].Unit
				return true
			end
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Regrowth</Name><Default>false</Default><SpellID>8936</SpellID><Actions></Actions><Lua>--Need to reword this one completely.

if PQR_SpellAvailable(8936) 
 and ( not Nova_Moving 
  or UnitBuffID(&amp;quot;player&amp;quot;, 117679) )  
 and Nova_Regrowth_Check then
	if not UnitBuffID(members[1].Unit, 8936)
	 and members[1].HP &amp;lt; Nova_Regrowth 
	 and (  UnitBuffID(&amp;quot;player&amp;quot;, 132158) ) then
	 	PQR_CustomTarget = members[1].Unit
	 	return true
	else
		if UnitBuffID(&amp;quot;player&amp;quot;, 16870) 
		 and members[1].HP &amp;lt; Nova_RegrowthCC then
		 	PQR_CustomTarget = members[1].Unit
		 	return true
		end
	end
end</Lua><RecastDelay>100</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Nourish</Name><Default>false</Default><SpellID>50464</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(50464)
 and not Nova_Moving  
 and Nova_Nourish_Check then
	if members[1].HP &amp;lt; Nova_Nourish then
		if UnitBuffID(members[1].Unit, 774)
		 or UnitBuffID(members[1].Unit, 8936) 
		 or UnitBuffID(members[1].Unit, 48438)
		 or UnitBuffID(members[1].Unit, 33763) then
		 	PQR_CustomTarget = members[1].Unit
		 	return true
		end
	end
	
	if not UnitBuffID(&amp;quot;player&amp;quot;, 100977) 
	 and UnitAffectingCombat(&amp;quot;player&amp;quot;) 
	 and Nova_CheckLastCast(50464, 2.5) then
		PQR_CustomTarget = members[1].Unit
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Healing Touch</Name><Default>false</Default><SpellID>5185</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(5185) 
 and not Nova_Moving  
 and Nova_HealingTouch_Check then
	if UnitBuffID(&amp;apos;player&amp;apos;, 16870)
	 and members[1].HP &amp;lt; Nova_HealingTouchCC then
	 	PQR_CustomTarget = members[1].Unit
	 	return true
	elseif UnitBuff(&amp;apos;player&amp;apos;, GetSpellInfo(144871)) then
		if select(4, UnitBuff(&amp;apos;player&amp;apos;,GetSpellInfo(144871))) &amp;gt;= 5 
		 and members[1].HP &amp;lt; Nova_HealingTouchCC then
		 	PQR_CustomTarget = members[1].Unit
		 	return true
		end
	elseif members[1].HP &amp;lt; Nova_HealingTouch then
	 	PQR_CustomTarget = members[1].Unit
	 	return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Wild Growth</Name><Default>false</Default><SpellID>48438</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(48438)  
 and Nova_WildGrowth_Check then
	GetDistance()
	local PerfectAoETarget = {}
	for i=1, #members do
		table.insert(PerfectAoETarget, {NumberNearby = UnitsClose(members[i].Unit, Nova_WildGrowth), Unit = members[i].Unit} )
	end
	
	table.sort(PerfectAoETarget, function(x,y) return x.NumberNearby &amp;gt; y.NumberNearby end)
	
	if PerfectAoETarget[1].NumberNearby &amp;gt;= 2
	 or AverageHealth(3) &amp;lt;= Nova_WildGrowth then
		PQR_CustomTarget = PerfectAoETarget[1].Unit
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Swiftmend</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if GetSpellCooldown(18562) == 0  
 and Nova_Swiftmend_Check then
 	if not GlyphCheck(145529) then
		GetDistance()
		local members = members
		
		local PerfectAoETarget = {}
		for i=1, #members do
			if UnitBuffID(members[i].Unit, 774) or UnitBuffID(members[i].Unit, 8936) then
				table.insert(PerfectAoETarget, {NumberNearby = UnitsClose(members[i].Unit, 85), Unit = members[i].Unit, HP = members[i].HP} )
			end
		end
	
		
		if #PerfectAoETarget &amp;gt; 0 then
			table.sort(PerfectAoETarget, function(x,y) return x.NumberNearby &amp;gt; y.NumberNearby end)
			
			if PerfectAoETarget[1].NumberNearby &amp;gt;= 3 then
				 CastSpellByName(GetSpellInfo(18562), PerfectAoETarget[1].Unit)
				 return true
			end
		end
	end

	
	if ( UnitBuffID(members[1].Unit, 774)
	 or UnitBuffID(members[1].Unit, 8936) ) then
	 	if members[1].HP &amp;lt;= Nova_Swiftmend then
	 		CastSpellByName(GetSpellInfo(18562), members[1].Unit)
	 		return true
	 	end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Natures Swiftness</Name><Default>false</Default><SpellID>132158</SpellID><Actions></Actions><Lua>-- Nature&amp;apos;s Swiftness
if PQR_SpellAvailable(132158)  
 and Nova_NaturesSwiftness_Check then
	if members[1].HP &amp;lt; Nova_NaturesSwiftness then
		return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Natures Cure</Name><Default>false</Default><SpellID>88423</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(88423) 
 and Nova_NaturesCure_Check then
	if members[1].HP &amp;gt; Nova_NaturesCure then
		for i=1, #members do
			if ValidDispel(members[i].Unit) then
			 	PQR_CustomTarget = members[i].Unit
			 	return true
			end
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Innervate</Name><Default>false</Default><SpellID>29166</SpellID><Actions></Actions><Lua>if UnitAffectingCombat(&amp;quot;player&amp;quot;)
 and select(3, Nova_UnitInfo(&amp;quot;player&amp;quot;)) &amp;lt;= Nova_Innervate  
 and Nova_Innervate_Check then
	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Inc: Swiftmend</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if UnitBuffID(&amp;quot;player&amp;quot;, 33891)  
 and Nova_Swiftmend_Check then
	if GetSpellCooldown(18562) == 0 then
		if not GlyphCheck(145529) then
			GetDistance()
			local members = members
			
			local PerfectAoETarget = {}
			for i=1, #members do
				if UnitBuffID(members[i].Unit, 774) or UnitBuffID(members[i].Unit, 8936) then
					table.insert(PerfectAoETarget, {NumberNearby = UnitsClose(members[i].Unit, 85), Unit = members[i].Unit, HP = members[i].HP} )
				end
			end
		
			
			if #PerfectAoETarget &amp;gt; 0 then
				table.sort(PerfectAoETarget, function(x,y) return x.NumberNearby &amp;gt; y.NumberNearby end)
				
				if PerfectAoETarget[1].NumberNearby &amp;gt;= 3 then
					 CastSpellByName(GetSpellInfo(18562), PerfectAoETarget[1].Unit)
					 return true
				end
			end
		end
	
		
		if ( UnitBuffID(members[1].Unit, 774)
		 or UnitBuffID(members[1].Unit, 8936) ) then
		 	if members[1].HP &amp;lt;= Nova_Swiftmend then
		 		CastSpellByName(GetSpellInfo(18562), members[1].Unit)
		 		return true
		 	end
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Ironbark</Name><Default>false</Default><SpellID>102342</SpellID><Actions></Actions><Lua>if PQR_SpellAvailable(102342) 
 and Nova_Ironbark_Check then 
	if #Nova_Tanks &amp;gt; 0 then
		for i=1, #Nova_Tanks do
			if UnitThreatSituation(Nova_Tanks[i].Unit) then
				if Nova_Tanks[i].HP &amp;lt; Nova_Ironbark then
					PQR_CustomTarget = Nova_Tanks[i].Unit
					return true
				end
			end
		end
	elseif UnitThreatSituation(members[1].Unit)
	 and members[1].HP &amp;lt; Nova_Ironbark then
	 	PQR_CustomTarget = members[1].Unit
	 	return true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Tranquility</Name><Default>false</Default><SpellID>740</SpellID><Actions></Actions><Lua>if Nova_ModTranquility
 and Nova_ModTranquility_Check
 and UnitAffectingCombat(&amp;quot;player&amp;quot;) then
 	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Natures Vigil</Name><Default>false</Default><SpellID>124974</SpellID><Actions></Actions><Lua>if members[1].HP &amp;lt; 50
 and AverageHealth(3) &amp;lt; Nova_NaturesVigil  
 and Nova_NaturesVigil_Check then
	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Master File --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>-- Only takes effect when we&amp;apos;re 90
if UnitLevel(&amp;quot;player&amp;quot;) == 90
 and not UnitIsDeadOrGhost(&amp;quot;player&amp;quot;)
 and Nova_CheckLastCast(6, 2) then
	-- If we are in a 5 man instance
	if IsInInstance() and select(2, GetInstanceInfo()) == &amp;quot;party&amp;quot; then
		FirstRun = false
		PQR_SwapRotation(&amp;quot;Party (Nova [Resto])&amp;quot;)
	-- If we are in a raid of any size
	elseif IsInInstance() and select(2, GetInstanceInfo()) == &amp;quot;raid&amp;quot; then
		FirstRun = false
		PQR_SwapRotation(&amp;quot;Raid (Nova [Resto])&amp;quot;)
	-- If we are in a Battleground
	elseif IsInInstance() and select(2, GetInstanceInfo()) == &amp;quot;pvp&amp;quot; and not IsActiveBattlefieldArena() and not IsRatedBattleground() then
		FirstRun = false
		PQR_SwapRotation(&amp;quot;BG (Nova [Resto])&amp;quot;)
	-- If we are in an Arena Battle
	elseif IsInInstance() and ( IsActiveBattlefieldArena() or IsRatedBattleground()) then
		FirstRun = false
		PQR_SwapRotation(&amp;quot;Arena (Nova [Resto])&amp;quot;)
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Party File --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if (not IsInInstance() or select(2, GetInstanceInfo()) ~= &amp;quot;party&amp;quot;) and not UnitIsDeadOrGhost(&amp;quot;player&amp;quot;) then
	PQR_SwapRotation(&amp;quot;Master (Nova [Resto])&amp;quot;)
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Arena File --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if not IsInInstance() and select(2, GetInstanceInfo()) ~= &amp;quot;pvp&amp;quot; and not UnitIsDeadOrGhost(&amp;quot;player&amp;quot;) then
	PQR_SwapRotation(&amp;quot;Master (Nova [Resto])&amp;quot;)
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Raid File --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if (not IsInInstance() or select(2, GetInstanceInfo()) ~= &amp;quot;raid&amp;quot;) and not UnitIsDeadOrGhost(&amp;quot;player&amp;quot;) then
	PQR_SwapRotation(&amp;quot;Master (Nova [Resto])&amp;quot;)
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- BG File --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if not IsInInstance() and select(2, GetInstanceInfo()) ~= &amp;quot;pvp&amp;quot; and not UnitIsDeadOrGhost(&amp;quot;player&amp;quot;) then
	PQR_SwapRotation(&amp;quot;Master (Nova [Resto])&amp;quot;)
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Stop Casting</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if SpellIsTargeting() then
	SpellStopCasting()
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Inc: Lifebloom</Name><Default>false</Default><SpellID>33763</SpellID><Actions></Actions><Lua>local members = members

if init == nil then
	init = true
	local LifeBloom = nil
end

if UnitExists(&amp;quot;focus&amp;quot;)
 and CanHeal(&amp;quot;focus&amp;quot;) then
 	LifeBloom = UnitGUID(&amp;quot;focus&amp;quot;)
elseif Nova_ModLifebloomSelector then
	if CanHeal(&amp;quot;mouseover&amp;quot;) 
	 or UnitIsUnit(&amp;quot;player&amp;quot;, &amp;quot;mouseover&amp;quot;) then
		LifeBloom = UnitGUID(&amp;quot;mouseover&amp;quot;)
		PQR_CustomTarget = &amp;quot;mouseover&amp;quot;
		return true
	end
end

if LifeBloom and ( UnitAffectingCombat(&amp;quot;player&amp;quot;) or UnitAffectingCombat(members[1].Unit) ) then
	for i=1, #members do
		if LifeBloom == members[i].GUID then
			if UnitBuffID(members[i].Unit, 33763) then
				if select(7, UnitBuffID(members[i].Unit, 33763)) - GetTime() &amp;lt;= 3 
				 or select(4, UnitBuffID(members[i].Unit, 33763)) &amp;lt; 3 then
					PQR_CustomTarget = members[i].Unit
					return true
				end
			else
				PQR_CustomTarget = members[i].Unit
				return true
			end
		end
	end
end

-- Incarnation Lifebloom Spam
if UnitBuffID(&amp;quot;player&amp;quot;, 33891) then
	for i=1, #members do
		if UnitBuffID(members[i].Unit, 33763) then
			if select(7, UnitBuffID(members[i].Unit, 33763)) - GetTime() &amp;lt;= 2 then
				PQR_CustomTarget = members[i].Unit
				return true
			end
		else
			PQR_CustomTarget = members[i].Unit
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Inc: Regrowth</Name><Default>false</Default><SpellID>8936</SpellID><Actions></Actions><Lua>--Need to reword this one completely.

if UnitBuffID(&amp;quot;player&amp;quot;, 33891) 
 and Nova_Regrowth_Check then
	if PQR_SpellAvailable(8936) 
	 and UnitBuffID(&amp;quot;player&amp;quot;, 117679) then
		if not UnitBuffID(members[1].Unit, 8936)
		 and members[1].HP &amp;lt; Nova_RegrowthCC
		 and ( UnitBuffID(&amp;quot;player&amp;quot;, 16870) 
		  or UnitBuffID(&amp;quot;player&amp;quot;, 132158) ) then
		 	PQR_CustomTarget = members[1].Unit
		 	return true
		end
	end
end</Lua><RecastDelay>100</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Incarnation</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if Nova_ModIncarnation
 and UnitAffectingCombat(&amp;quot;player&amp;quot;) 
 and Nova_ModIncarnation_Check then
 	CastSpellByName(GetSpellInfo(106731), &amp;quot;player&amp;quot;)
 	return true
end</Lua><RecastDelay>0</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Inc: Wild Growth</Name><Default>false</Default><SpellID>48438</SpellID><Actions></Actions><Lua>if UnitBuffID(&amp;quot;player&amp;quot;, 33891)  
 and Nova_WildGrowth_Check then
	if PQR_SpellAvailable(48438) then
		GetDistance()
		local PerfectAoETarget = {}
		for i=1, #members do
			table.insert(PerfectAoETarget, {NumberNearby = UnitsClose(members[i].Unit, Nova_WildGrowth), Unit = members[i].Unit} )
		end
		
		table.sort(PerfectAoETarget, function(x,y) return x.NumberNearby &amp;gt; y.NumberNearby end)
		
		if PerfectAoETarget[1].NumberNearby &amp;gt;= 2
		 or AverageHealth(3) &amp;lt;= Nova_WildGrowth then
			PQR_CustomTarget = PerfectAoETarget[1].Unit
			return true
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Custom</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Genesis</Name><Default>false</Default><SpellID>145518</SpellID><Actions></Actions><Lua>if GenesisFinder() then
	return true
end</Lua><RecastDelay>1000</RecastDelay><Target>Player</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Blacklist --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if  Nova_ModAddOrRemoveBlacklist then
--Nova_ModAddOrRemoveBlacklist_Check then
 	local funcResult = nil
	if UnitExists(&amp;quot;mouseover&amp;quot;) then
		funcResult = AddOrRemoveBlacklist(&amp;quot;mouseover&amp;quot;)
	elseif UnitExists(&amp;quot;target&amp;quot;) then
		funcResult = AddOrRemoveBlacklist(&amp;quot;mouseover&amp;quot;)
	end
	
	if funcResult and 
	 (funcResult == 1 or funcResult == 2) then
		if funcResult == 1 then
			PQR_WriteToChat(&amp;quot;We removed &amp;quot;..select(2, funcResult)..&amp;quot; from your Blacklist!&amp;quot;)
		else
			PQR_WriteToChat(&amp;quot;We added &amp;quot;..select(2, funcResult)..&amp;quot; from your Blacklist!&amp;quot;)
		end
	end		
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Soul of the Forest</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>return SoulOfTheForest()</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>Wild Mushrooms</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>return WildMushrooms()</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Spell Queue Setup --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>-- I am going to create a simple frame that will accept either SPELL ID input, or SPELL NAME input...
-- I will try and distinguish which is being requested by simple string verifications..
-- Spell ID will be simple in adding to the Queue system
-- Spell Name will be slightly more complex.. Possible ideas on how to compare Spell Name against possible Spell choices
---- We can use a predetermined table of Spell ID&amp;apos;s to accept as Spell Name inputs
---- We can scan the entire SpellBook before we even begin and see what spells we know (Run check whenever Spec or Level changes)
---- Still thinking about other methods
-- I may include a Scroll Frame which will display the last X number or Queued Casts and if they were successful or not
if not Nova_Queue_Setup then
local function Event_Reader()

	local function OnEventFunc(self, event, ...)
		if event == &amp;quot;PLAYER_LEVEL_UP&amp;quot; or event == &amp;quot;PLAYER_TALENT_UPDATE&amp;quot; then
			Nova_SpellBookCache = { }
			local _, _, tabOffset, numEntries = GetSpellTabInfo(2) -- The Spell Tab 1 = General Spells, 2 = Current Spec spells
			for i=tabOffset + 1, tabOffset + numEntries do
				local spellName, spellSubName = GetSpellBookItemName(i, &amp;quot;spell&amp;quot;)
				local spell = GetSpellLink(spellName)
				if ( not spellSubName or not string.match(spellSubName, &amp;quot;Passive&amp;quot;) )
				 and spell then
					local SpellNameFinal = string.lower(gsub(spellName, &amp;quot;[%s%d%p]&amp;quot;, &amp;quot;&amp;quot;))
					local string1 = gsub(spell, &amp;quot;[%a%|%s%[%]]+&amp;quot;, &amp;quot;&amp;quot;)
					local spellIDfromString = tonumber(string.match(string1, &amp;quot;%p(%d+)&amp;quot;))
					table.insert(Nova_SpellBookCache, { name = SpellNameFinal, id = spellIDfromString } )
				end
			end	
		elseif #Nova_SpellQueueTable &amp;gt; 0 and event == &amp;quot;COMBAT_LOG_EVENT_UNFILTERED&amp;quot; then
			if (select(2, ...) == &amp;quot;SPELL_CAST_SUCCESS&amp;quot;
				or select(2, ...) == &amp;quot;SPELL_CAST_START&amp;quot; )
			 and select(4, ...) == UnitGUID(&amp;quot;player&amp;quot;) then			 	
			 	for loop = 1, #Nova_SpellQueueTable do
			 		if Nova_SpellQueueTable[loop].id == select(12, ...) then
			 			table.remove(Nova_SpellQueueTable, loop)
			 			print(&amp;quot;|cff00F0F0Successfully cast|cffFF0000&amp;quot;,select(13, ...),&amp;quot;|cff00F0F0!&amp;quot;)
			 			break
			 		end
			 	end
			end
		end
	end


	local eventReader = CreateFrame(&amp;quot;frame&amp;quot;, nil)
	eventReader:RegisterEvent(&amp;quot;PLAYER_LEVEL_UP&amp;quot;)
	eventReader:RegisterEvent(&amp;quot;PLAYER_TALENT_UPDATE&amp;quot;)
	eventReader:RegisterEvent(&amp;quot;COMBAT_LOG_EVENT_UNFILTERED&amp;quot;)
	eventReader:SetScript(&amp;quot;OnEvent&amp;quot;, OnEventFunc)

end

function CheckForValidSpell(string)
	-- We need to figure out if we&amp;apos;re dealing with a SpellID or a Spell Name
	local SpellIDCheck = gsub(string, &amp;quot;[%a%p%s]&amp;quot;, &amp;quot;&amp;quot;)
	local SpellNameCheck = string.lower(gsub(string, &amp;quot;[%s%d%p]&amp;quot;, &amp;quot;&amp;quot;))
	
	if type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;number&amp;quot; or type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;string&amp;quot; then
		SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, 0)
	end
	
	-- First We&amp;apos;ll check the Spell ID as it is a quicker check, and return true if we successfully add
	if string.len(SpellIDCheck) &amp;gt; 0 then
		local SpellID = tonumber(SpellIDCheck)
		for t=1, #Nova_SpellBookCache do
			if SpellID == Nova_SpellBookCache[t].id then
				if #Nova_SpellQueueTable &amp;gt; 0 then
					for j=1, #Nova_SpellQueueTable do
						if Nova_SpellBookCache[t].id == Nova_SpellQueueTable[j].id then
							print(&amp;quot;|cff00F0F0Removing|cffFF0000&amp;quot;, GetSpellInfo(Nova_SpellQueueTable[j].id), &amp;quot;|cff00F0F0from the Spell Queue before it was cast!&amp;quot;)
							table.remove(Nova_SpellQueueTable, j)
							return false
						end
					end
				end
				table.insert(Nova_SpellQueueTable, { name = Nova_SpellBookCache[t].name, id = Nova_SpellBookCache[t].id })
				NovaSpellQueueHistory(Nova_SpellBookCache[t].id)
				print(&amp;quot;|cff00F0F0Successfully added |cffFF0000&amp;quot;..GetSpellInfo(Nova_SpellBookCache[t].id)..&amp;quot;|cff00F0F0 to the Spell Queue&amp;quot;)
				return 
			end
		end
	end

	-- If we had a string that appeared to be an ID we&amp;apos;ll check that first, if nothign returns true, we
	-- will then check the Spell Name and if that is a true Spell
	if string.len(SpellNameCheck) &amp;gt; 0 then
		for k=1, #Nova_SpellBookCache do
			if SpellNameCheck == Nova_SpellBookCache[k].name then
				if #Nova_SpellQueueTable &amp;gt; 0 then
					for j=1, #Nova_SpellQueueTable do
						if Nova_SpellBookCache[k].id == Nova_SpellQueueTable[j].id then	
							print(&amp;quot;|cff00F0F0Removing|cffFF0000&amp;quot;, GetSpellInfo(Nova_SpellQueueTable[j].id), &amp;quot;|cff00F0F0from the Spell Queue before it was cast!&amp;quot;)
							table.remove(Nova_SpellQueueTable, j)
							return false
						end
					end
				end
				table.insert(Nova_SpellQueueTable, { name = Nova_SpellBookCache[k].name, id = Nova_SpellBookCache[k].id })
				NovaSpellQueueHistory(Nova_SpellBookCache[k].id)
				print(&amp;quot;|cff00F0F0Successfully added |cffFF0000&amp;quot;..GetSpellInfo(Nova_SpellBookCache[k].id)..&amp;quot;|cff00F0F0 to the Spell Queue&amp;quot;)
				return 
			end
		end
	else return false
	end
	
	print(&amp;quot;|cffFF00FFThere wasn&amp;apos;t a Spell to go along with what your input&amp;quot;)
	return false
end


function NovaSpellQueueHistory(spellID)
	local buttonID = spellID
	local buttonName = GetSpellInfo(buttonID)
	local AlreadyInHistory = false
	-- We are seeing if it&amp;apos;s already in the Spell Queue History or not
	-- If not, we will create a new button if 6 don&amp;apos;t exists already
	-- Or we will overwrite the oldest Spell in the History
	for h=1, #Nova_SpellQueueHistory do
		if buttonID == Nova_SpellQueueHistory[h].id then
			table.sort(Nova_SpellQueueHistory, function(x) return x.id == spellID end)
			AlreadyInHistory = true
		end
	end
	if not AlreadyInHistory then
		if #Nova_SpellQueueHistory &amp;lt;= 5 then
				local spellButton = CreateFrame(&amp;quot;button&amp;quot;, &amp;quot;SpellQueueSystemButton&amp;quot;..tostring(#Nova_SpellQueueHistory + 1), SpellQueueSystemContent, &amp;quot;UIPanelButtonTemplate&amp;quot;)
				spellButton:SetSize(110, 20)
				spellButton:SetScript(&amp;quot;OnClick&amp;quot;, function(self) 
					SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, self:GetText())
				end)
				table.insert(Nova_SpellQueueHistory, 1, {name=buttonName, id=buttonID, button=spellButton}) 
		elseif #Nova_SpellQueueHistory == 6 then
				Nova_SpellQueueHistory[6].id = buttonID
				Nova_SpellQueueHistory[6].name = buttonName
				table.sort(Nova_SpellQueueHistory, function(x) return x.id == spellID end)
		end
	end
	
	local startPointX, startPointY = 10, 5
	for i=1, #Nova_SpellQueueHistory do
		local ButtonSetting = Nova_SpellQueueHistory[i].button
		ButtonSetting:SetText(Nova_SpellQueueHistory[i].name)
		ButtonSetting:ClearAllPoints()
		if i &amp;lt;= 3 then
			ButtonSetting:SetPoint(&amp;quot;TOPLEFT&amp;quot;, SpellQueueSystemContent, &amp;quot;TOPLEFT&amp;quot;, startPointX, - (startPointY + (24 * (i-1))))
		else
			ButtonSetting:SetPoint(&amp;quot;TOPRIGHT&amp;quot;, SpellQueueSystemContent, &amp;quot;TOPRIGHT&amp;quot;, - startPointX , - (startPointY + (24 * (i-4))))
		end
	end
end

function Nova_Queue_Setup()
	if GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;) == nil then RegisterCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;) end
	Nova_SpellBookCache = { }
	Nova_SpellQueueTable = { }
	Nova_SpellQueueHistory = { }
	local _, _, tabOffset, numEntries = GetSpellTabInfo(2) -- The Spell Tab 1 = General Spells, 2 = Current Spec spells
	for i=tabOffset + 1, tabOffset + numEntries do
		local spellName, spellSubName = GetSpellBookItemName(i, &amp;quot;spell&amp;quot;)
		local spell = GetSpellLink(spellName)
		if ( not spellSubName or not string.match(spellSubName, &amp;quot;Passive&amp;quot;) )
		 and spell then
			local SpellNameFinal = string.lower(gsub(spellName, &amp;quot;[%s%d%p]&amp;quot;, &amp;quot;&amp;quot;))
			local string1 = gsub(spell, &amp;quot;[%a%|%s%[%]]+&amp;quot;, &amp;quot;&amp;quot;)
			local spellIDfromString = tonumber(string.match(string1, &amp;quot;%p(%d+)&amp;quot;))
			table.insert(Nova_SpellBookCache, { name = SpellNameFinal, id = spellIDfromString } )
		end
	end	

	-- Title
	local frameTitle = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;SpellQueueSystemTitle&amp;quot;, UIParent)
	frameTitle:ClearAllPoints()
	frameTitle:SetSize(120, 27)	
	frameTitle:SetMovable(true)
	frameTitle:EnableMouse(true)
	frameTitle:RegisterForDrag(&amp;quot;LeftButton&amp;quot;)
	frameTitle:SetScript(&amp;quot;OnDragStart&amp;quot;, frameTitle.StartMoving)
	frameTitle:SetScript(&amp;quot;OnDragStop&amp;quot;, frameTitle.StopMovingOrSizing)
	frameTitle:SetScript(&amp;quot;OnShow&amp;quot;, RefreshFrameBoxes)
	local TitleString = frameTitle:CreateFontString(&amp;quot;TitleString&amp;quot;)
	TitleString:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
	TitleString:SetText(&amp;quot;Spell Queue System&amp;quot;)
	TitleString:SetJustifyH(&amp;quot;CENTER&amp;quot;)
	TitleString:SetJustifyV(&amp;quot;CENTER&amp;quot;)
	TitleString:ClearAllPoints()
	TitleString:SetPoint(&amp;quot;TOPLEFT&amp;quot;, SpellQueueSystemTitle, &amp;quot;TOPLEFT&amp;quot;)
	TitleString:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, SpellQueueSystemTitle, &amp;quot;BOTTOMRIGHT&amp;quot;)
	frameTitle:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																tile = true, tileSize = 16, edgeSize = 16, 
																insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameTitle:SetBackdropColor(0,0,0,1);
	frameTitle:SetPoint(&amp;quot;CENTER&amp;quot;, -300, 100)
	frameTitle:Hide()
	
	
	-- Main Frame that we shall link everything to
	local frameMain = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;SpellQueueSystem&amp;quot;, SpellQueueSystemTitle)
	frameMain:ClearAllPoints()
	frameMain:SetSize(260, 115)
	frameMain:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																tile = true, tileSize = 16, edgeSize = 16, 
																insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameMain:SetBackdropColor(0,0,0,1);
	frameMain:SetPoint(&amp;quot;TOP&amp;quot;, SpellQueueSystemTitle, &amp;quot;BOTTOM&amp;quot;, 0, -2)
	frameMain:Show()




	-- Close/Hide Button
	local frameClose = CreateFrame(&amp;apos;Button&amp;apos;, &amp;apos;SpellQueueSystemClose&amp;apos;, frameMain)
	frameClose:ClearAllPoints()
	frameClose:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, frameMain, &amp;quot;TOPRIGHT&amp;quot;, 0, 4)
	frameClose:RegisterForClicks(&amp;quot;LeftButtonDown&amp;quot;)
	frameClose:SetSize(20, 20)
	local closeText = frameClose:CreateFontString(&amp;quot;closeText&amp;quot;)
	closeText:SetFontObject(&amp;quot;GameTooltipTextSmall&amp;quot;)
	closeText:SetText(&amp;quot;|cFFFFFAFA X|cffffffff&amp;quot;)
	closeText:ClearAllPoints()
	closeText:SetAllPoints(frameClose)
	closeText:SetJustifyH(&amp;quot;CENTER&amp;quot;)
	closeText:SetJustifyV(&amp;quot;CENTER&amp;quot;)
	frameClose:SetScript(&amp;apos;OnClick&amp;apos;, function() frameTitle:Hide() end )
	frameClose:SetBackdrop({ 
									edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
									tile = false, tileSize = 12, edgeSize = 12, 
									insets = { left = 6, right = 6, top = 6, bottom = 6 }
									})
	frameClose:Show()
	
	-- Content Frame
	local frameContent = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;SpellQueueSystemContent&amp;quot;, frameMain)
	frameContent:ClearAllPoints()
	frameContent:SetPoint(&amp;quot;TOPLEFT&amp;quot;, frameMain, &amp;quot;TOPLEFT&amp;quot;, 5, -28)
	frameContent:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, frameMain, &amp;quot;BOTTOMRIGHT&amp;quot;, -5, 5)
	frameContent:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																tile = true, tileSize = 8, edgeSize = 8, 
																insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameContent:SetBackdropColor(0,0,0,1);
	
	-- EditBox
	local frameEditbox = CreateFrame(&amp;quot;Editbox&amp;quot;, &amp;quot;SpellQueueSystemEditbox&amp;quot;, frameMain, &amp;quot;InputBoxTemplate&amp;quot;)
	frameEditbox:SetSize(180, 18)
	frameEditbox:ClearAllPoints()
	frameEditbox:SetAutoFocus(false)
	frameEditbox:ClearFocus()
	frameEditbox:SetPoint(&amp;quot;BOTTOMLEFT&amp;quot;, frameContent, &amp;quot;TOPLEFT&amp;quot;, 8, 4)
	frameEditbox:SetScript(&amp;quot;OnEnterPressed&amp;quot;, function(self) 
		SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, self:GetText())
		self:SetText(&amp;quot;&amp;quot;)
		self:ClearFocus() 
	end)
	frameEditbox:SetScript(&amp;quot;OnEscapePressed&amp;quot;, function(self) self:SetText(&amp;quot;&amp;quot;); self:ClearFocus() end)

	-- Accept Button
	local frameAccept = CreateFrame(&amp;quot;Button&amp;quot;, &amp;quot;SpellQueueSystemAccept&amp;quot;, frameEditbox, &amp;quot;UIPanelButtonTemplate&amp;quot;)
	frameAccept:SetBackdrop({edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
							tile = true, tileSize = 8, edgeSize = 8, 
							insets = { left = 4, right = 4, top = 4, bottom = 4 }});
	frameAccept:SetBackdropBorderColor(1,1,1,1);
	frameAccept:SetNormalFontObject(&amp;quot;GameTooltipText&amp;quot;)
	frameAccept:SetText(&amp;quot;Accept&amp;quot;)
	frameAccept:SetSize(60, 18)
	frameAccept:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, frameContent, &amp;quot;TOPRIGHT&amp;quot;, 0, 4)
	frameAccept:SetScript(&amp;quot;OnClick&amp;quot;, function() 
		SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, frameEditbox:GetText())
		frameEditbox:SetText(&amp;quot;&amp;quot;)
		frameEditbox:ClearFocus() 
	end)

	Event_Reader()
	


end
end

SLASH_NOVASPELLQUEUE1 = &amp;quot;/novaspell&amp;quot;
function SlashCmdList.NOVASPELLQUEUE(spellText, editbox)
	if spellText ~= &amp;quot;firstrun&amp;quot; then
		if issecure() then
			SetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;, spellText)
		else
			print(&amp;quot;Not Secure to use the Slash Commands, use Frame from now on, until you can /console reloadui&amp;quot;)
		end
	end
end

if not Setup then
	Nova_Queue_Setup()
	
	SLASH_NOVASPELLFRAME1 = &amp;quot;/nsq&amp;quot;
	function SlashCmdList.NOVASPELLFRAME(spellText, editbox)
		if not _G.SpellQueueSystemTitle:IsVisible() then
			_G.SpellQueueSystemTitle:Show()
		else
			_G.SpellQueueSystemTitle:Hide()
		end
	end
	
	RunMacroText(&amp;quot;/novaspell firstrun&amp;quot;)
	Setup = true
end

if type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;string&amp;quot; or type(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;)) == &amp;quot;number&amp;quot; then
	CheckForValidSpell(GetCVar(&amp;apos;Nova_CheckForValidSpell&amp;apos;))
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- Spell Queue Cast --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>if #Nova_SpellQueueTable &amp;gt; 0 then
	for i=1, #Nova_SpellQueueTable do
		spell = Nova_SpellQueueTable[i].id
		if select(2, GetSpellCooldown(spell)) == 0 
		 or ( ( GetSpellCooldown(spell) + select(2, GetSpellCooldown(spell)) - GetTime() ) &amp;lt; 0.5 ) then
			SpellCancelQueuedSpell() -- Blizzard Function, not related to my Frame
			CastSpellByName(GetSpellInfo(spell))
		end
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>False</CancelChannel><SkipUnknown>True</SkipUnknown></Ability><Ability><Name>-- VHT --</Name><Default>false</Default><SpellID>0</SpellID><Actions></Actions><Lua>-- We are going to create a Frame that will support multiple Healing Tables and visually show them...
-- We will try to add in targeting support by clicking the names of the Tagets shown on the Table...
-- We will try and make it look clean and orderly, while looking simplistic in design...
-- Layout for information will be in said order
-- Name  |  Actual HP%  |  Weighted HP%  |  In Range of Heals (for Custom Table)
-- Still debating on Update Time (how frequently to refresh data)
-- Should I allow sorting based on other factors (for the Visual part only, not the healing part)
if not VHT_List or not VHT_Timer or not VHT_FramePool then
	VHT_List = { }
	VHT_FramePool = { }
	VHT_Timer = 0
end
if not VisualTableFrameSetup then
	function UpdateVisualTable(tableName, VHT)
		local tableName, VHT = tableName, VHT
		local startPoint_X, startPoint_Y = 10, 16
		local frameScrollContent = _G[&amp;apos;VisualHealingTableScrollContent&amp;apos;]
	
		-- Name Font String Setup
		for i=1, #VHT do		
			local TestName = VHT[i].name
			TestName:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
			TestName:ClearAllPoints()
			TestName:SetText(GetUnitName(tableName[i].Unit, true))
			TestName:SetSize(150, 13)
			TestName:SetPoint(&amp;quot;TOPLEFT&amp;quot;, frameScrollContent, &amp;quot;TOPLEFT&amp;quot;, 10, - 12 - (14 * i) )
		end
	
		-- HP Font String Setup
		for i=1, #VHT do
			local TestHP = VHT[i].HP
			TestHP:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
			TestHP:ClearAllPoints()
			TestHP:SetText(math.floor(tableName[i].HP))
			TestHP:SetSize(40, 13)
			TestHP:SetTextHeight(12)
			TestHP:SetJustifyH(&amp;quot;CENTER&amp;quot;)
			TestHP:SetPoint(&amp;quot;LEFT&amp;quot;, VHT[i].name, &amp;quot;RIGHT&amp;quot;, 4, 0 )
		end
		
		_G[&amp;apos;VHT_Timer&amp;apos;] = GetTime()
	
	end
	
	function RemoveFrames()
		local VHT_Frame = tremove(VHT_List, #VHT_List)
	
		VHT_Frame.name:Hide()
		VHT_Frame.HP:Hide()
		VHT_Frame.range:Hide()
	
		table.insert(VHT_FramePool, VHT_Frame)
	end
	
	function GetFrames(valueVHT)
		local i = valueVHT
		if #VHT_FramePool &amp;gt; 0 then
			local VHT_Frame = tremove(VHT_FramePool)
			local VHT_FrameName, VHT_FrameHP, VHT_FrameRange = VHT_Frame.name, VHT_Frame.HP, VHT_Frame.range
			VHT_FrameName:Show()
			VHT_FrameHP:Show()
			VHT_FrameRange:Show()
			
			table.insert(VHT_List, { name = VHT_FrameName, HP = VHT_FrameHP, range = VHT_FrameRange })
		else
			local Frame = _G[&amp;apos;VisualHealingTableScrollContent&amp;apos;]
			local VHT_FrameName = Frame:CreateFontString(&amp;quot;FontStringName&amp;quot;..tostring(i))
			VHT_FrameName:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
			VHT_FrameName:SetHeight(12)
			VHT_FrameName:SetText(&amp;quot;Test&amp;quot;)
			local VHT_FrameHP = Frame:CreateFontString(&amp;quot;FontStringHP&amp;quot;..tostring(i))
			VHT_FrameHP:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
			VHT_FrameHP:SetHeight(12)
			local VHT_FrameRange = Frame:CreateFontString(&amp;quot;FontStringRange&amp;quot;..tostring(i))
			VHT_FrameRange:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
			VHT_FrameRange:SetHeight(12)
			
			table.insert(VHT_List, { name = VHT_FrameName, HP = VHT_FrameHP, range = VHT_FrameRange })
		end
	end
	
	function UpdateFontStrings(tableName)
		local VHTDD = _G[&amp;apos;VisualHealingTableDropDown&amp;apos;].selectedID
		local tableName = tableName[VHTDD]
	
		if #tableName ~= #VHT_List then
			if #tableName &amp;lt; #VHT_List then
				i = #VHT_List
				while #tableName ~= i do
					RemoveFrames()
	
					i = i - 1
				end
			elseif #tableName &amp;gt; #VHT_List then
				local i=#VHT_List
				while i ~= #tableName do				
					i = i + 1
					GetFrames(i)
				end
			end
		end
	
	
		-- Content frame and Scroll Bar Max Value updating
		local frameScrollContent = _G[&amp;apos;VisualHealingTableScrollContent&amp;apos;]
		local frameScrollBar = _G[&amp;apos;VisualHealingTableScrollBar&amp;apos;]
		frameScrollContent:SetHeight(20 + (#VHT_List * 13))
		frameScrollBar:SetMinMaxValues(1, (frameScrollContent:GetHeight() - 19))
	
		if select(2, frameScrollBar:GetMinMaxValues()) &amp;gt;= 50 and not frameScrollBar:IsShown() then
			frameScrollBar:Show()
		elseif select(2, frameScrollBar:GetMinMaxValues()) &amp;lt; 50 and frameScrollBar:IsShown() then
	 		frameScrollBar:Hide()
		end
	
		UpdateVisualTable(tableName, VHT_List)
	end
	
	
	
	function VisualTableFrameSetup(tableNames)
		if type(tableNames) ~= table then
			local tableNames = { tableNames }
		else
			local tableNames = tableNames
		end
	
	
		-- Title
		local frameTitle = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;VisualHealingTableTitle&amp;quot;, UIParent)
		frameTitle:ClearAllPoints()
		frameTitle:SetSize(150, 27)	
		frameTitle:SetMovable(true)
		frameTitle:EnableMouse(true)
		frameTitle:RegisterForDrag(&amp;quot;LeftButton&amp;quot;)
		frameTitle:SetScript(&amp;quot;OnDragStart&amp;quot;, frameTitle.StartMoving)
		frameTitle:SetScript(&amp;quot;OnDragStop&amp;quot;, frameTitle.StopMovingOrSizing)
		frameTitle:SetScript(&amp;quot;OnShow&amp;quot;, RefreshFrameBoxes)
		local TitleString = frameTitle:CreateFontString(&amp;quot;TitleString&amp;quot;)
		TitleString:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
		TitleString:SetText(&amp;quot;Visual Healing Table&amp;quot;)
		TitleString:SetJustifyH(&amp;quot;CENTER&amp;quot;)
		TitleString:SetJustifyV(&amp;quot;CENTER&amp;quot;)
		TitleString:ClearAllPoints()
		TitleString:SetPoint(&amp;quot;TOPLEFT&amp;quot;, VisualHealingTableTitle, &amp;quot;TOPLEFT&amp;quot;)
		TitleString:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, VisualHealingTableTitle, &amp;quot;BOTTOMRIGHT&amp;quot;)
		frameTitle:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																	edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																	tile = true, tileSize = 16, edgeSize = 16, 
																	insets = { left = 4, right = 4, top = 4, bottom = 4 }});
		frameTitle:SetBackdropColor(0,0,0,1);
		frameTitle:SetPoint(&amp;quot;CENTER&amp;quot;, -300, 100)
		frameTitle:Hide()
		
		
		-- Main Frame that we shall link everything to
		local frameMain = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;VisualHealingTable&amp;quot;, VisualHealingTableTitle)
		frameMain:ClearAllPoints()
		frameMain:SetSize(320, 140)
		frameMain:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																	edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																	tile = true, tileSize = 16, edgeSize = 16, 
																	insets = { left = 4, right = 4, top = 4, bottom = 4 }});
		frameMain:SetBackdropColor(0,0,0,1);
		frameMain:SetPoint(&amp;quot;TOP&amp;quot;, VisualHealingTableTitle, &amp;quot;BOTTOM&amp;quot;, 0, -2)
		frameMain:Show()
	
	
	
	
		-- Close/Hide Button
		local frameClose = CreateFrame(&amp;apos;Button&amp;apos;, &amp;apos;frameClose&amp;apos;, frameMain, &amp;quot;UIPanelButtonTemplate&amp;quot;)
		frameClose:ClearAllPoints()
		frameClose:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, frameMain, &amp;quot;TOPRIGHT&amp;quot;, 20, 4)
		frameClose:RegisterForClicks(&amp;quot;LeftButtonDown&amp;quot;)
		frameClose:SetSize(20, 20)
		local closeText = frameClose:CreateFontString(&amp;quot;closeText&amp;quot;)
		closeText:SetFontObject(&amp;quot;GameTooltipTextSmall&amp;quot;)
		closeText:SetText(&amp;quot;|cFFFFFAFA X|cffffffff&amp;quot;)
		closeText:ClearAllPoints()
		closeText:SetAllPoints(frameClose)
		closeText:SetJustifyH(&amp;quot;CENTER&amp;quot;)
		closeText:SetJustifyV(&amp;quot;CENTER&amp;quot;)
		frameClose:SetScript(&amp;apos;OnClick&amp;apos;, function() frameTitle:Hide() end )
		frameClose:SetBackdrop({
										--bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
										edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
										tile = false, tileSize = 12, edgeSize = 12, 
										insets = { left = 6, right = 6, top = 6, bottom = 6 }
										})
		frameClose:Show()
	
		-- DropDownMenu
		   
		local frameDropDown = CreateFrame(&amp;quot;Button&amp;quot;, &amp;quot;VisualHealingTableDropDown&amp;quot;, VisualHealingTableTitle, &amp;quot;UIDropDownMenuTemplate&amp;quot;)
		 
		frameDropDown:ClearAllPoints()
		frameDropDown:SetPoint(&amp;quot;TOPLEFT&amp;quot;, frameMain, &amp;quot;TOPLEFT&amp;quot;, -2, -3)
		frameDropDown:Show()
		 
		local function OnClick(self)
		   UIDropDownMenu_SetSelectedID(frameDropDown, self:GetID())
		end
		 
		local function initialize(self, level)
			local info = UIDropDownMenu_CreateInfo()
			for i=1, #tableNames do
				info = UIDropDownMenu_CreateInfo()
				info.text = &amp;quot;Table &amp;quot;..tostring(i)
				info.func = OnClick
				UIDropDownMenu_AddButton(info, level)
			end
		end
		 
		
	
		UIDropDownMenu_Initialize(frameDropDown, initialize)
		UIDropDownMenu_SetWidth(frameDropDown, 100);
		UIDropDownMenu_SetButtonWidth(frameDropDown, 124)
		UIDropDownMenu_SetSelectedID(frameDropDown, 1)
		UIDropDownMenu_JustifyText(frameDropDown, &amp;quot;LEFT&amp;quot;)
		
	
		-- Scroll Frame Creation (Scary!!!!)
		local frameScroll = CreateFrame(&amp;quot;ScrollFrame&amp;quot;, &amp;quot;VisualHealingTableScroll&amp;quot;, VisualHealingTable) 
		frameScroll:SetPoint(&amp;quot;TOPLEFT&amp;quot;, 10, -30) 
		frameScroll:SetPoint(&amp;quot;BOTTOMRIGHT&amp;quot;, -10, 10) 
		frameScroll:SetBackdrop({bgFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Background&amp;quot;, 
																	edgeFile = &amp;quot;Interface/Tooltips/UI-Tooltip-Border&amp;quot;, 
																	tile = true, tileSize = 8, edgeSize = 8, 
																	insets = { left = 4, right = 4, top = 4, bottom = 4 }});
		frameScroll:SetBackdropColor(0,0,0,.8);
		frameMain.frameScroll = frameScroll 
	
		--scrollbar 
		local frameScrollBar = CreateFrame(&amp;quot;Slider&amp;quot;, &amp;quot;VisualHealingTableScrollBar&amp;quot;, frameScroll, &amp;quot;UIPanelScrollBarTemplate&amp;quot;) 
		frameScrollBar:SetPoint(&amp;quot;TOPLEFT&amp;quot;, frameMain, &amp;quot;TOPRIGHT&amp;quot;, 4, -16) 
		frameScrollBar:SetPoint(&amp;quot;BOTTOMLEFT&amp;quot;, frameMain, &amp;quot;BOTTOMRIGHT&amp;quot;, 4, 16) 
		frameScrollBar:SetMinMaxValues(1, 30) 
		frameScrollBar:SetValueStep(1) 
		frameScrollBar.scrollStep = 1 
		frameScrollBar:SetValue(0) 
		frameScrollBar:SetWidth(16)
		frameScrollBar:SetScript(&amp;quot;OnValueChanged&amp;quot;, 
		function (self, value) 
		self:GetParent():SetVerticalScroll(value) 
		end) 
		local scrollbg = frameScrollBar:CreateTexture(nil, &amp;quot;BACKGROUND&amp;quot;) 
		scrollbg:SetAllPoints(frameScrollBar) 
		scrollbg:SetTexture(0, 0, 0, 0.4) 
		frameMain.frameScrollBar = frameScrollBar
		frameScrollBar:Hide()
		
		-- Content Frame
		local frameScrollContent = CreateFrame(&amp;quot;frame&amp;quot;, &amp;quot;VisualHealingTableScrollContent&amp;quot;, frameScroll)
		frameScrollContent:ClearAllPoints()
		frameScrollContent:SetWidth(300)
		frameScrollContent:SetHeight(20)
		frameScroll:SetScrollChild(frameScrollContent)
		local NameTitle = frameScrollContent:CreateFontString(&amp;quot;NameTitle&amp;quot;)
		NameTitle:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
		NameTitle:SetSize(150, 13)
		NameTitle:SetTextHeight(13)
		NameTitle:SetJustifyV(&amp;quot;CENTER&amp;quot;)
		NameTitle:SetJustifyH(&amp;quot;CENTER&amp;quot;)
		NameTitle:SetTextColor(1, 1, 0, 1)
		NameTitle:SetText(&amp;quot;Name&amp;quot;)
		NameTitle:SetPoint(&amp;quot;TOPLEFT&amp;quot;, frameScrollContent, &amp;quot;TOPLEFT&amp;quot;, 10, -2)
		local HPTitle = frameScrollContent:CreateFontString(&amp;quot;HPTitle&amp;quot;)
		HPTitle:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
		HPTitle:SetSize(40, 13)
		HPTitle:SetTextHeight(13)
		HPTitle:SetJustifyV(&amp;quot;CENTER&amp;quot;)
		HPTitle:SetJustifyH(&amp;quot;CENTER&amp;quot;)
		HPTitle:SetTextColor(1, 1, 0, 1)
		HPTitle:SetText(&amp;quot;HP %&amp;quot;)
		HPTitle:SetPoint(&amp;quot;LEFT&amp;quot;, NameTitle, &amp;quot;RIGHT&amp;quot;, 4, 0)
		local RangeTitle = frameScrollContent:CreateFontString(&amp;quot;RangeTitle&amp;quot;)
		RangeTitle:SetFontObject(&amp;quot;GameTooltipText&amp;quot;)
		RangeTitle:SetSize(50, 13)
		RangeTitle:SetTextHeight(13)
		RangeTitle:SetJustifyV(&amp;quot;CENTER&amp;quot;)
		RangeTitle:SetJustifyH(&amp;quot;CENTER&amp;quot;)
		RangeTitle:SetTextColor(1, 1, 0, 1)
		RangeTitle:SetText(&amp;quot;Range&amp;quot;)
		RangeTitle:SetPoint(&amp;quot;LEFT&amp;quot;, HPTitle, &amp;quot;RIGHT&amp;quot;, 4, 0)
		local line1 = frameScrollContent:CreateTexture()
		line1:ClearAllPoints()
		line1:SetHeight(1)
		line1:SetTexture(.9, .9, 0, .8)
		line1:SetPoint(&amp;quot;TOPLEFT&amp;quot;, NameTitle, &amp;quot;BOTTOMLEFT&amp;quot;, 0, -2)	
		line1:SetPoint(&amp;quot;TOPRIGHT&amp;quot;, RangeTitle, &amp;quot;BOTTOMRIGHT&amp;quot;, 0, -2)
		local line2 = frameScrollContent:CreateTexture()
		line2:ClearAllPoints()
		line2:SetWidth(1)
		line2:SetHeight(13)
		line2:SetTexture(.9, .9, 0, .8)
		line2:SetPoint(&amp;quot;LEFT&amp;quot;, NameTitle, &amp;quot;RIGHT&amp;quot;, 0, 0)	
		local line3 = frameScrollContent:CreateTexture()
		line3:ClearAllPoints()
		line3:SetWidth(1)
		line3:SetHeight(13)
		line3:SetTexture(.9, .9, 0, .8)
		line3:SetPoint(&amp;quot;RIGHT&amp;quot;, RangeTitle, &amp;quot;LEFT&amp;quot;, 0, 0)
	
	
		UpdateFontStrings(tableNames)
		_G[&amp;quot;FrameSetup&amp;quot;] = true
	end
end</Lua><RecastDelay>0</RecastDelay><Target>Target</Target><CancelChannel>True</CancelChannel><SkipUnknown>True</SkipUnknown></Ability></DRUID>