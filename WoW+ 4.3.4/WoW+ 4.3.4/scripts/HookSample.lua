-- HookSample v1.0
-- Demonstrates how to use the memory hooking api
-- Registers a toplevel command (!target) to create a teleport to our current target.

-- Get a 1kb CodeCave where we can put in our assembly stuff...
local CodeCave = Memory.Allocate();

function Load()
	-- Write the assembly code (ret) to our codecave.
	-- We need this to force a return on a detoured function.
	Memory.WriteBuffer( CodeCave, 0xC3 );

	-- Hook the SendChatMessage function
	Memory.Hook( ChatHook, Memory.GetModuleBase() + 0x4E8840 );
end

function Unload()
	-- Free the allocated memory for our codecave...
	Memory.Free( CodeCave );
end

function ChatHook( hookID, address, eax, ebp, ebx, ecx, edi, edx, eip, esi, esp )
	-- Message is in ESI
	local message = Memory.ReadString( esi );

	-- Check if message is "!target"
	if message == "!target" then
		-- Port to Target
		TeleportToTarget();

		-- We don't want to send the message: Jump to our "return" codecave.
		-- EIP is the jump back address when our codecave finishes execution.
		Memory.HookSetContext( eax, ebp, ebx, ecx, edi, edx, CodeCave, esi, esp );
	end
end

function TeleportToTarget()
	local target = ObjectManager.GetCurrentTarget();
	if target ~= nil then
		Plus.CreateTeleportEvent( target:GetLocation() );
	end
end