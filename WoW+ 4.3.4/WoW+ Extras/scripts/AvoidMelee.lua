-- AvoidMelee v1.0
-- Ports you behind your enemys if they get too close in combat!

local nearestDist = nil;
local nearestObj = nil;

function Load()
	Plus.PrintChat( "AvoidMelee v1.0 loaded" );
	Event.RegisterTimerCallback( Pulse, 100, true );
end

function Unload()
end

function Pulse( eventID, interval )
	if Plus.IsTeleportActive() then
		return;
	end

	nearestDist = nil;
	nearestObj = nil;
	
	local currPlayer = ObjectManager.GetActivePlayer();
	local pX, pY, pZ = currPlayer:GetLocation();
	
	local entryCount = ObjectManager.GetObjectListEntryCount();
	for i = 1, entryCount do
		local object = ObjectManager.GetObjectListEntry( i );
		if object:GetType() == 3 and InCombatWith( object ) then
			local oX, oY, oZ = object:GetLocation();
			local currDist = GetDistance2D( pX, pY, oX, oY );
			if nearestDist == nil or currDist < nearestDist then
				nearestDist = currDist;
				nearestObj = object;
			end
		end
	end
	
	if nearestObj ~= nil and nearestDist < 10 then
		local x, y, z = nearestObj:GetLocation();
		local rotation = nearestObj:GetRotation();
		
		local rx1, ry1, rz1;
		local rx2, ry2, rz2;
		for i = 1, 3 do
			rx1, ry1, rz1 = FixCurrentZLevel( GetRelativeLocation( x, y, z, rotation, 25, i ) );
			rx2, ry2, rz3 = D3D.TraceLine( x, y, z, rx1, ry1, rz1, Bit.Or( INTERSECT_TERRAIN, INTERSECT_WMO ) );
			if rx2 ~= nil then
				break;
			end
		end
		
		Plus.CreateTeleportEvent( rx1, ry1, rz1 );
		Event.RegisterCallback( OnTeleportComplete, "OnTeleportEventCompleted" );
	end
end

function OnTeleportComplete( eventID, eventType )
	Event.RemoveCallback( eventID );
	Player.Face( nearestObj:GetLocation() );
end

function GetDistance2D( x1, y1, x2, y2 )
	local diffX = x1 - x2;
	local diffY = y1 - y2;
	return math.sqrt( math.pow( diffX, 2 ) + math.pow( diffY, 2 ) );
end

function InCombatWith( unit )
	local unitGUID = unit:GetGUID();
	local affectingCombat = Plus.DoString( "return UnitAffectingCombat( '" .. unitGUID .. "' )" );
	local queryResult = Plus.DoString( "return UnitDetailedThreatSituation( 'player', '" .. unitGUID .. "' )" );
	return queryResult ~= "nil" and affectingCombat == "1";
end

function GetRelativeLocation( x, y, z, rotation, distance, direction )
	if( direction == 0 ) then
		x = x + ( distance * math.cos( rotation ) );
		y = y + ( distance * math.sin( rotation ) );
	elseif( direction == 1 ) then
		x = x - ( distance * math.cos( rotation ) );
		y = y - ( distance * math.sin( rotation ) );
	elseif( direction == 2 ) then
		x = x + ( distance * math.cos( rotation + math.pi / 2 ) );
		y = y + ( distance * math.sin( rotation + math.pi / 2 ) );
	elseif( direction == 3 ) then
		x = x - ( distance * math.cos( rotation + math.pi / 2 ) );
		y = y - ( distance * math.sin( rotation + math.pi / 2 ) );
	elseif( direction == 4 ) then
		z = z + distance;
	elseif( direction == 5 ) then
		z = z - distance;
	end
	
	return x, y, z;
end

function FixCurrentZLevel( x, y, z )
	local r1, r2, r3 = D3D.TraceLine( x, y, z - 10, x, y, z + 20, Bit.Or( INTERSECT_TERRAIN, INTERSECT_WMO ) );
	if r1 ~= nil then
		return r1, r2, r3;
	end
	
	return x, y, z;
end
